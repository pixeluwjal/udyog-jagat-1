// app/api/seeker/onboarding/route.ts
import { NextRequest, NextResponse } from 'next/server';
import dbConnect from '@/lib/dbConnect';
import User from '@/models/User';
import { authMiddleware } from '@/lib/authMiddleware';
import mongoose from 'mongoose';
import { GridFSBucket } from 'mongodb';
import jwt from 'jsonwebtoken';
import { Readable } from 'stream'; // Import Readable from 'stream'

export const config = {
  api: {
    bodyParser: false,
  },
};

export async function POST(request: NextRequest) {
  await dbConnect();
  console.log('\n--- API: /api/seeker/onboarding POST - Request received ---');

  const authResult = await authMiddleware(request, 'job_seeker');
  if (!authResult.success) {
    console.warn(`API: Onboarding failed auth: ${authResult.message}`);
    return NextResponse.json({ error: authResult.message }, { status: authResult.status });
  }

  const authenticatedUser = authResult.user;

  if (!authenticatedUser) {
    console.error('API: Authenticated user data is unexpectedly null.');
    return NextResponse.json({ error: 'Authentication data missing.' }, { status: 500 });
  }

  const { id: userId, email, role } = authenticatedUser;

  if (role !== 'job_seeker') {
    console.warn(`API: User ${userId} (role: ${role}) attempted to complete seeker onboarding. Forbidden.`);
    return NextResponse.json({ error: 'Forbidden - Only job seekers can complete this onboarding.' }, { status: 403 });
  }

  try {
    const formData = await request.formData();
    const fullName = formData.get('fullName')?.toString();
    const phone = formData.get('phone')?.toString();
    const skills = formData.get('skills')?.toString();
    const experience = formData.get('experience')?.toString();
    const resumeFile = formData.get('resume') as File | null;

    console.log(`API: Onboarding attempt for user ${userId} (${email}).`);
    console.log(`API: Received data - Full Name: ${fullName}, Phone: ${phone}, Skills: ${skills}, Experience: ${experience}`);
    console.log(`API: Resume file received: ${resumeFile ? resumeFile.name : 'No file'}`);

    if (!fullName || !phone || !skills || !experience || !resumeFile) {
      return NextResponse.json({ error: 'All fields are required: Full Name, Phone, Skills, Experience, and Resume.' }, { status: 400 });
    }

    if (resumeFile.type !== 'application/pdf') {
      return NextResponse.json({ error: 'Only PDF files are allowed for resumes.' }, { status: 400 });
    }

    const MAX_FILE_SIZE_MB = 10;
    if (resumeFile.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
      return NextResponse.json({ error: `Resume file size exceeds ${MAX_FILE_SIZE_MB}MB limit.` }, { status: 400 });
    }

    const connection = mongoose.connection;
    if (!connection.db) {
        throw new Error('MongoDB connection is not established for GridFS.');
    }

    const bucket = new GridFSBucket(connection.db, {
      bucketName: 'resumes',
    });

    const buffer = Buffer.from(await resumeFile.arrayBuffer());
    const readableStream = new Readable(); // Use imported Readable
    readableStream._read = () => {};
    readableStream.push(buffer);
    readableStream.push(null);

    const uploadStream = bucket.openUploadStream(
      `${userId}_${Date.now()}_${resumeFile.name.replace(/[^a-zA-Z0-9._-]/g, '_')}`,
      {
        contentType: resumeFile.type,
        metadata: {
          userId: userId,
          originalName: resumeFile.name,
          uploadDate: new Date(),
        },
      }
    );

    const fileId = uploadStream.id; // This is the _id generated by GridFS for the file
    console.log(`DEBUG: fileId after openUploadStream.id: ${fileId}, type: ${typeof fileId}, instanceof ObjectId: ${fileId instanceof mongoose.Types.ObjectId}`); // DEBUG 1

    await new Promise((resolve, reject) => {
      readableStream.pipe(uploadStream)
        .on('error', (error: any) => {
          console.error('GridFS upload stream error:', error);
          reject(new Error('Failed to upload resume to GridFS.'));
        })
        .on('finish', () => {
          console.log(`Resume uploaded to GridFS. File ID: ${fileId}`);
          resolve(null);
        });
    });

    // Update user document
    const user = await User.findById(userId);

    if (!user) {
      console.error(`API: User ${userId} not found during onboarding update.`);
      // If user not found but resume uploaded, you might want to delete the uploaded file from GridFS
      // await bucket.delete(fileId); // Consider implementing cleanup if this happens
      return NextResponse.json({ error: 'User not found.' }, { status: 404 });
    }

    if (!user.username) {
      user.username = user.email.split('@')[0];
      console.log(`API: Username was undefined, re-derived from email: '${user.username}'`);
    }

    // Ensure candidateDetails is assigned
    user.candidateDetails = {
      fullName,
      phone,
      skills: skills.split(',').map(s => s.trim()).filter(s => s),
      experience,
    };
    
    // --- THIS IS THE CRITICAL ASSIGNMENT ---
    user.resumeGridFsId = fileId; 
    // --- END CRITICAL ASSIGNMENT ---

    user.onboardingStatus = 'completed';
    user.firstLogin = false;

    console.log(`DEBUG: User object before save - resumeGridFsId: ${user.resumeGridFsId}`); // DEBUG 2
    console.log(`DEBUG: User object before save (JSON.stringify): ${JSON.stringify(user.toObject())}`); // DEBUG 3

    try {
        await user.save();http://localhost:3000/poster/applications
        console.log(`API: User ${userId} (${email}) onboarding completed and data saved. Resume GridFS ID: ${fileId}`);
    } catch (saveError: any) {
        console.error('API: Error saving user after onboarding:', saveError); // Catch any save errors
        return NextResponse.json({ error: saveError.message || 'Failed to save user data after onboarding.' }, { status: 500 });
    }
    
    if (!process.env.JWT_SECRET) {
      throw new Error('JWT_SECRET is not defined.');
    }
    const newToken = jwt.sign(
      {
        id: user.id.toString(),
        email: user.email,
        role: user.role,
        firstLogin: user.firstLogin,
        isSuperAdmin: user.isSuperAdmin,
        onboardingStatus: user.onboardingStatus,
        username: user.username,
        resumeGridFsId: user.resumeGridFsId?.toString(), // Ensure this is included in the token
      },
      process.env.JWT_SECRET,
      { expiresIn: '1d' }
    );
    console.log(`API: New token generated for user ${userId} with updated onboarding status and username.`);

    const responseUser = {
      _id: user.id.toString(),
      username: user.username,
      email: user.email,
      role: user.role,
      firstLogin: user.firstLogin,
      isSuperAdmin: user.isSuperAdmin,
      onboardingStatus: user.onboardingStatus,
      candidateDetails: user.candidateDetails,
      resumeGridFsId: user.resumeGridFsId?.toString(), // Include in response for frontend
    };

    return NextResponse.json(
      { message: 'Onboarding completed successfully!', user: responseUser, token: newToken },
      { status: 200 }
    );

  } catch (error: unknown) {
    console.error('API: Onboarding error:', error);
    let errorMessage = 'Server error during onboarding.';
    if (error instanceof Error) {
      errorMessage = error.message;
    } else if (typeof error === 'string') {
      errorMessage = error;
    }
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}